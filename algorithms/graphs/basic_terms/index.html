<!DOCTYPE html>
<html lang="en">

<head>

    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-66582-32"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-66582-32');
    </script>

    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="Basic Terminology and Inspection" />
<meta property="og:description" content="Node Inspection For this, we&rsquo;ll throw together a bare-bones network representing a straight-line, directed path from 1 to 4, peppering in weights along the edges.
%pylab inline import networkx as nx F = nx.DiGraph() F.add_weighted_edges_from([(1, 2, .3), (2, 3, .4), (3, 4, .5)]) Populating the interactive namespace from numpy and matplotlib  Simple stuff, yeah?
nx.draw_networkx(F) Here, we built F with simple integers, but we could have just as easily used str or any other hashable type." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://napsterinblue.github.io/notes/algorithms/graphs/basic_terms/" />



<meta property="article:published_time" content="2021-02-11T00:00:00&#43;00:00"/>

<meta property="article:modified_time" content="2021-02-11T00:00:00&#43;00:00"/>











<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Basic Terminology and Inspection"/>
<meta name="twitter:description" content="Node Inspection For this, we&rsquo;ll throw together a bare-bones network representing a straight-line, directed path from 1 to 4, peppering in weights along the edges.
%pylab inline import networkx as nx F = nx.DiGraph() F.add_weighted_edges_from([(1, 2, .3), (2, 3, .4), (3, 4, .5)]) Populating the interactive namespace from numpy and matplotlib  Simple stuff, yeah?
nx.draw_networkx(F) Here, we built F with simple integers, but we could have just as easily used str or any other hashable type."/>
<meta name="generator" content="Hugo 0.40.3" />

    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Basic Terminology and Inspection",
  "url": "https://napsterinblue.github.io/notes/algorithms/graphs/basic_terms/",
  "wordCount": "1581",
  "datePublished": "2021-02-11T00:00:00&#43;00:00",
  "dateModified": "2021-02-11T00:00:00&#43;00:00",
  "author": {
    "@type": "Person",
    "name": ""
  }
}
</script> 

    <title>Basic Terminology and Inspection</title>

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb"
        crossorigin="anonymous">

    
    <link href="https://napsterinblue.github.io/notes/css/custom.css" rel="stylesheet">
    <link href="https://napsterinblue.github.io/notes/css/syntax.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Muli:400,500,700" rel="stylesheet">

    <link href="" rel="alternate" type="application/rss+xml" title="Data Science Notes" />

    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});
</script>

</head>

<body>

    <nav class="navbar navbar-expand-sm fixed-top">
        <div class="container-fluid">
            <a class="navbar-brand" href="https://napsterinblue.github.io">Movies, Metrics, Musings</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="nav navbar-nav mr-auto"></ul>
                <ul class="nav navbar-nav">
                    <li><a href="https://napsterinblue.github.io/pages/about.html" title="About">About</a></li>
                    <li><a href="https://napsterinblue.github.io/archives.html" title="Archive">Archive</a></li>
                    <li><a href="https://napsterinblue.github.io/pages/resources.html" title="Resources">Resources</a></li>
                    <li><a href="https://napsterinblue.github.io/notes/" title="Notes">My Notes</a></li>

                </ul>
            </div>
        </div>
    </nav>


    
    <div class="container">
        <div class="row">
            <div class="col-sm-12">

                 


<article>
  <div class="technical_note">
  <header>
    <h1 class="technical_note_title">Basic Terminology and Inspection</h1>
    <div class="technical_note_date">
      <time datetime=" 2021-02-11T00:00:00Z "> 11 Feb 2021</time>
    </div>
  </header>
  <div class="content">
  

<h2 id="node-inspection">Node Inspection</h2>

<p>For this, we&rsquo;ll throw together a bare-bones network representing a straight-line, <em>directed</em> path from <code>1</code> to <code>4</code>, peppering in weights along the edges.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">%</span><span class="n">pylab</span> <span class="n">inline</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="n">F</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">.</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">)])</span></code></pre></div>
<pre><code>Populating the interactive namespace from numpy and matplotlib
</code></pre>

<p>Simple stuff, yeah?</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">F</span><span class="p">)</span></code></pre></div>
<p><img src="basic_terms_4_0.png" alt="png" /></p>

<p>Here, we built <code>F</code> with simple integers, but we could have just as easily used <code>str</code> or any other hashable type.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">F</span><span class="o">.</span><span class="n">nodes</span></code></pre></div>
<pre><code>NodeView((1, 2, 3, 4))
</code></pre>

<p>Now, if we want to drill in to any particular node, we can simply subscript the Graph object by it&rsquo;s node label</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">F</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></code></pre></div>
<pre><code>AtlasView({3: {'weight': 0.4}})
</code></pre>

<p>As you can see, this only gives us a partial picture&ndash; namely the <em>outbound</em> edge(s) and the relevant edge attributes.</p>

<p>If instead, we wanted to see everything&ndash; incoming and outgoing&ndash; we&rsquo;d use the <code>nx.all_neighbors()</code> method</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">all_neighbors</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span></code></pre></div>
<pre><code>[1, 3]
</code></pre>

<p>However you&rsquo;ll notice that we lost the convenience of getting the edge attribute, automagically</p>

<h3 id="a-less-simple-dataset">A Less-Simple Dataset</h3>

<p>In order to dive into more macro measures, we&rsquo;ll import the canonical Graph Dataset that analyzes the social network of a karate class.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">karate_club_graph</span><span class="p">()</span>
<span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)</span></code></pre></div>
<pre><code>networkx.classes.graph.Graph
</code></pre>

<p>Inspecting the type of <code>G</code>, we can see that it&rsquo;s a <code>Graph</code> (as opposed to a <em>directional</em> graph) and therefore the edge that connects two nodes doesn&rsquo;t have any inherent direction associated to it.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span></code></pre></div>
<p><img src="basic_terms_14_0.png" alt="png" /></p>

<h3 id="clustering">Clustering</h3>

<p>Quoting the book, &ldquo;Some social theories consider triads essential units of social network analysis.&rdquo; So what does that mean?</p>

<p>Well, I actually found this to be a little counter-intuitive.</p>

<p>For starters, let&rsquo;s look at a random node in our network, <code>15</code>. It&rsquo;s kinda hanging out on its own, only sharing a connection with two other nodes</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="p">[</span><span class="mi">15</span><span class="p">],</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;gold&#39;</span><span class="p">);</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="mi">15</span><span class="p">],</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">);</span></code></pre></div>
<p><img src="basic_terms_16_0.png" alt="png" /></p>

<p>32 and 33</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">G</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span></code></pre></div>
<pre><code>AtlasView({32: {}, 33: {}})
</code></pre>

<p>Critically, however, these two nodes are <em>also</em> connected to one another</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="mi">33</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span></code></pre></div>
<pre><code>True
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="mi">32</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span></code></pre></div>
<pre><code>True
</code></pre>

<p>And so in this un-directed graph, you could potentially cycle through the <em>triangle</em> <code>15-32-33-15...</code> forever.</p>

<p>On the other hand, consider node 9. It <em>also</em> only connects to two nodes</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">G</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span></code></pre></div>
<pre><code>AtlasView({2: {}, 33: {}})
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;gold&#39;</span><span class="p">);</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">);</span></code></pre></div>
<p><img src="basic_terms_24_0.png" alt="png" /></p>

<p>But as you might be able to see from the picture, its neighbors <em>aren&rsquo;t</em> connected.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="mi">33</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></code></pre></div>
<pre><code>False
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="mi">2</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span></code></pre></div>
<pre><code>False
</code></pre>

<p>So what does this mean?</p>

<p>Well, in the context of (social) networks, a node&rsquo;s <code>clustering coefficient</code> is a measure of &ldquo;what percent of all possible triangles exist between a node and all possible pairs of adjacent nodes?&rdquo;</p>

<p>That&rsquo;s a mouthful. Let&rsquo;s try and unpack a little. We&rsquo;ll do this by looking more closely at a more middle-of-the-road node. Here, I&rsquo;ve gotten each node&rsquo;s clustering coefficient and I spy that node <code>10</code> will probably give us what we&rsquo;re after.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">clustering</span><span class="p">(</span><span class="n">G</span><span class="p">))</span></code></pre></div>
<pre><code>{0: 0.15, 1: 0.3333333333333333, 2: 0.24444444444444444, 3: 0.6666666666666666, 4: 0.6666666666666666, 5: 0.5, 6: 0.5, 7: 1.0, 8: 0.5, 9: 0, 10: 0.6666666666666666, 11: 0, 12: 1.0, 13: 0.6, 14: 1.0, 15: 1.0, 16: 1.0, 17: 1.0, 18: 1.0, 19: 0.3333333333333333, 20: 1.0, 21: 1.0, 22: 1.0, 23: 0.4, 24: 0.3333333333333333, 25: 0.3333333333333333, 26: 1.0, 27: 0.16666666666666666, 28: 0.3333333333333333, 29: 0.6666666666666666, 30: 0.5, 31: 0.2, 32: 0.19696969696969696, 33: 0.11029411764705882}
</code></pre>

<p>It&rsquo;s got three neighbors</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">G</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span></code></pre></div>
<pre><code>AtlasView({0: {}, 4: {}, 5: {}})
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">circular_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;gold&#39;</span><span class="p">);</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">);</span></code></pre></div>
<p><img src="basic_terms_32_0.png" alt="png" /></p>

<p>Which makes for a possibility of <code>3-choose-2</code> possible triangle pairs:</p>

<pre><code>0, 4
0, 5
4, 5
</code></pre>

<p>Examining each pair for connectivity, we get <sup>2</sup>&frasl;<sub>3</sub> of the neighboring connections, and therefore <sup>2</sup>&frasl;<sub>3</sub> of the possible triangles realized.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="mi">0</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span></code></pre></div>
<pre><code>True
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="mi">0</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span></code></pre></div>
<pre><code>True
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="mi">4</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span></code></pre></div>
<pre><code>False
</code></pre>

<p>Therefore, node <code>10</code> has a connectivity coefficient of .6666</p>

<h3 id="transitivity">Transitivity</h3>

<p>Taken as a whole, the <code>transitivity</code> of a network, gives you a one-shot look at &ldquo;number of triangles / number of all possible triangles&rdquo;</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">nx</span><span class="o">.</span><span class="n">transitivity</span><span class="p">(</span><span class="n">G</span><span class="p">)</span></code></pre></div>
<pre><code>0.2556818181818182
</code></pre>

<h3 id="density">Density</h3>

<p>Another, similar measure of &ldquo;how interconnected is my network&rdquo; is its <code>density</code>.</p>

<p>To work this out we&rsquo;ll start with the fact that there are 34 nodes in our Graph</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span></code></pre></div>
<pre><code>34
</code></pre>

<p>and therefore, are 561 possible pairs of nodes (assuming <code>(m, n) == (n, m)</code> in an undirected graph).</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="mi">34</span><span class="o">*</span><span class="mi">33</span><span class="o">/</span><span class="mi">2</span></code></pre></div>
<pre><code>561.0
</code></pre>

<p>Looking at our data, we can see there are 78 lines connecting pairs of data, <code>edges</code></p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">num_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
<span class="n">num_edges</span></code></pre></div>
<pre><code>78
</code></pre>

<p>And therefore 483 <code>non_edges</code> between all of the other pairs that <em>don&rsquo;t</em> share an edge</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">num_non_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">non_edges</span><span class="p">(</span><span class="n">G</span><span class="p">)))</span>
<span class="n">num_non_edges</span></code></pre></div>
<pre><code>483
</code></pre>

<p>Which is to say that all possible pairs in our graph are accounted for, between <code>edges</code> and <code>non_edges</code></p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="mi">561</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_edges</span> <span class="o">+</span> <span class="n">num_non_edges</span><span class="p">)</span></code></pre></div>
<pre><code>True
</code></pre>

<p>Therefore, we can define the <code>density</code> of our Graph as &ldquo;the ratio of connected pairs to all possible pairs in the network&rdquo;.</p>

<p>The Karate Graph has a density of approximately .14, which we can calculate manually</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="mi">78</span><span class="o">/</span><span class="p">(</span><span class="mi">78</span><span class="o">+</span><span class="mi">483</span><span class="p">)</span></code></pre></div>
<pre><code>0.13903743315508021
</code></pre>

<p>or use the function provided by <code>networkx</code></p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">nx</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="n">G</span><span class="p">)</span></code></pre></div>
<pre><code>0.13903743315508021
</code></pre>

<p><strong>Note:</strong> When working with networks where the direction <em>does</em> matter, this <code>density</code> measure will be <em>half</em> of what we calculated in the undirected case&ndash; because each pair could <em>also</em> have an edge that connects in the opposite direction</p>

<h3 id="the-difference">The Difference</h3>

<p>Two measures (transitivity and density) follow the same form of &ldquo;number observed shapes / number of possible shapes&rdquo;, but truth be told, I don&rsquo;t have a strong grasp on when one is a more appropriate measure than the other for evaluating a network as a whole.</p>

<h2 id="paths">Paths</h2>

<p>I&rsquo;m sure the mechanics of this will get worked out at length in another notebook, but for now, I wanted to get a few core definitions down.</p>

<p>Before we do, though, I want to point out that <strong>for this particular network</strong>, it&rsquo;s possible to ping-pong from node to node such that no matter where you start, you can always reach the terminal node of interest. Or to start in on the terminology, we can say that there exists a <code>walk</code>&ndash; a sequence of edges&ndash; that connect any two points in our graph.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">node_1</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">node_2</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">nx</span><span class="o">.</span><span class="n">has_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node_1</span><span class="p">,</span> <span class="n">node_2</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;No errors&#39;</span><span class="p">)</span></code></pre></div>
<pre><code>No errors
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span></code></pre></div>
<p><img src="basic_terms_57_0.png" alt="png" /></p>

<p>Tightening that definition, a <code>trail</code> is a <code>walk</code> that never visits the same edge twice. Its length is guaranteed to be less than or equal to any other valid walk between two points, because if there was a revisited edge, we would just take whatever the final step off of that node would be, instead.</p>

<p>A <code>cycle</code> is a <code>trail</code> that begins and ends at the same place. Our earlier discussion of &ldquo;completed triangles&rdquo; is a great example of a <code>cycle</code>.</p>

<p>Tightening even further, a <code>path</code> is a <code>trail</code> that never visists the same node twice.</p>

<p>And finally, a <code>geodesic</code> is a two-dollar word meaning &ldquo;shortest simple path.&rdquo; It has no redundant steps, and gets from point A to point B in the minimum number of steps. Here, we can see that there&rsquo;s a path that exists, connecting nodes <code>8</code> and <code>24</code>.</p>

<p>Moreover, we can use the built-in function <code>shortest_path</code> to determine what it is.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">shortest_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
<span class="n">shortest_path</span></code></pre></div>
<pre><code>[8, 2, 27, 24]
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">shortest_path</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;gold&#39;</span><span class="p">);</span></code></pre></div>
<p><img src="basic_terms_60_0.png" alt="png" /></p>

<h2 id="graphs-as-circles">Graphs as Circles</h2>

<p><em>This part still throws me for a bit of a loop, but the book also concedes that it&rsquo;s a bit tricky to grok, so I&rsquo;ll try and be careful.</em></p>

<p>Graph Networks borrow a lot of their descriptors from geometric terms used to describe circles. But before we get into that I want to define <code>node eccentricity</code> as a measure of how far from the normal/center node a point is. Note that prefix&ndash; <code>ecc</code>, interchangeable with the Latin <code>ex</code>, meaning &ldquo;out&rdquo;, so taken literally, this means &ldquo;measure of how far out from the center&rdquo; a given node is.</p>

<p>In the graph context, this is expressed as the max distance from a node to all other nodes in the network, like so</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">print</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">G</span><span class="p">))</span></code></pre></div>
<pre><code>{0: 3, 1: 3, 2: 3, 3: 3, 4: 4, 5: 4, 6: 4, 7: 4, 8: 3, 9: 4, 10: 4, 11: 4, 12: 4, 13: 3, 14: 5, 15: 5, 16: 5, 17: 4, 18: 5, 19: 3, 20: 5, 21: 4, 22: 5, 23: 5, 24: 4, 25: 4, 26: 5, 27: 4, 28: 4, 29: 5, 30: 4, 31: 3, 32: 4, 33: 4}
</code></pre>

<p>Which should track.</p>

<p>If you&rsquo;d describe someone as &ldquo;eccentric&rdquo; you&rsquo;d likely also use the phrase &ldquo;out there&rdquo; which has a more literal interpretation here than I might have expected!</p>

<p>Where it gets confusing is borrowing the circle terminology.</p>

<p><code>diameter</code> is the maximum <code>eccentricity</code> for a graph</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">max_ecc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_ecc</span></code></pre></div>
<pre><code>True
</code></pre>

<p><code>radius</code> is the <em>minimum</em> <code>eccentricity</code> of a Graph</p>

<p><strong>Note</strong>: and has NO proportional relationship to the <code>diameter</code> whatsover</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">min_ecc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">nx</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="n">min_ecc</span></code></pre></div>
<pre><code>True
</code></pre>

<p>Using these terms, we&rsquo;d say that the <code>center</code> of a graph, is a set of all nodes whose <code>eccentricity</code> is equal to the <code>radius</code></p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">center_nodes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">center_nodes</span></code></pre></div>
<pre><code>[0, 1, 2, 3, 8, 13, 19, 31]
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">center_nodes</span><span class="p">]</span></code></pre></div>
<pre><code>[3, 3, 3, 3, 3, 3, 3, 3]
</code></pre>

<p>Similarly, the <code>periphery</code> represents all nodes whose <code>eccentricity</code> is equal to the <code>diameter</code></p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">periphery_nodes</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">periphery</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">periphery_nodes</span></code></pre></div>
<pre><code>[14, 15, 16, 18, 20, 22, 23, 26, 29]
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">eccentricity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">periphery_nodes</span><span class="p">]</span></code></pre></div>
<pre><code>[5, 5, 5, 5, 5, 5, 5, 5, 5]
</code></pre>

</div>
  <aside>
      <div class="bug_reporting">
          <h4>Find an error or bug?</h4>
          <p>Everything on this site is available on GitHub. Head to <a href='https://github.com/napsterinblue/notes/issues/new'>and submit a suggested change</a>. You can also message me directly on <a href='https://twitter.com/napsterinblue'>Twitter</a>.</p>
      </div>
      </aside>

    </div>
</article>




            </div>

        </div>
    </div>

    

    <footer class="footer text-center">
        <div class="container">
            <span class="text-muted">This project contains 185 pages and is available on <a href="https://github.com/napsterinblue/notes">GitHub</a>. Copyright &copy; NapsterInBlue, <time datetime="2018">2018</time>.</span>
        </div>
    </footer>

    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" integrity="sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh"
        crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js" integrity="sha384-alpBpkh1PFOepccYVYDB4do5UnbKysX5WZXm3XxPqe5iKTfUKjNkCk9SaVuEZflJ"
        crossorigin="anonymous"></script>

</body>

</html>
